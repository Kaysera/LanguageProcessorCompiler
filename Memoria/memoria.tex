\documentclass[11pt]{article}
\usepackage[spanish,activeacute]{babel}
\usepackage{enumerate}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{color}
\usepackage{alltt}
\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\usepackage{subcaption}
\usepackage{listings}
%\usepackage{mathtools}
\usepackage{amsmath}
%\usepackage{amssymb}
%Gummi|065|=)

%\parindent 3em 
%\oddsidemargin 0.45in
%\textwidth 5.75in
%\parskip 0.05in
%\topmargin 0in
%ESTO ES COSA DEL LISTINGS
	\usepackage{listingsutf8}
%	\usepackage{inconsolata}
	\usepackage{xcolor}
	\definecolor{dkgreen}{rgb}{0,0.6,0}
	\definecolor{greenv2}{rgb}{0,0.9,0}
	\definecolor{gray}{rgb}{0.5,0.5,0.5}
	\definecolor{mauve}{rgb}{0.58,0,0.82}
	
	\lstset{
	  frame=l,  % Agregar el marco b -> bottom, t -> top, tb ambos
	  aboveskip=3mm,
	  belowskip=3mm,
	  rulecolor=\color{greenv2},
	  showstringspaces=false,
	  columns=flexible,
	  basicstyle={\small\ttfamily},
	  numbers=left,
	  numberstyle=\tiny\color{gray},
	  numbersep=5pt,
	  keywordstyle=\color{blue},
	  commentstyle=\color{dkgreen},
	  stringstyle=\color{mauve},
	  breaklines=true,
	  breakatwhitespace=true
	  inputencoding=utf8
	  extendedchars=true,
	  literate={ñ}{{\~n}}1 {>}{$>$}1 {<}{$<$}1 {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1 {¿}{\textquestiondown}1 ,
	  tabsize=3
	}
	\lstset{numbers=left, numberstyle={\scriptsize } , stepnumber=1, numbersep=8pt}

%ESTO ES COSA DEL LISTINGS
\newcommand{\nt}[1]{\langle#1\rangle}
\newcommand{\regla}[2]{\nt{#1} \ \ \ &\rightarrow \ \ \ #2 \\}
\newcommand{\refcano}[1]{\hypersetup{pdfborder=0 0 1}\hyperref{#1}{}{}{#1}\hypersetup{pdfborder=0 0 0}}
\title{\textbf{Procesadores de Lenguajes}}
\author{Guillermo Tomás Fernández Martín, Luís González Naharro}


\begin{document}



\begin{titlepage}

\begin{center}
\vspace*{-1in}
\begin{figure}[htb]
\begin{center}
\includegraphics[width=8cm]{esiilogo.jpg}
\end{center}
\end{figure}

FACULTAD DE INGENIER'IA INFORM'ATICA\\
\vspace*{0.15in}
PROCESADORES DE LENGUAJES\\
\vspace*{0.15in}
\vspace*{0.2in}
\begin{Large}
\textbf{Práctica 3: Desarrollo de un compilador sencillo - Memoria} \\
\end{Large}
\vspace*{0.3in}

\rule{80mm}{0.1mm}\\
\vspace*{0.1in}
\vspace*{0.3in}
\begin{large}
Realizado por:\\ Guillermo Tomás Fernández Martín, Luís González Naharro\\
\textit{\{GuillermoTomas.Fernandez, Luis.Gonzalez9\}@alu.uclm.es}

\end{large}
\end{center}
%\begin{flushright}
%Albacete, 2 de junio de 2013
%\end{flushright}

\end{titlepage}
\thispagestyle{empty}
\vspace*{7in}

\pagenumbering{roman}
\setcounter{page}{0}
\tableofcontents
\newpage
\lstlistoflistings
\newpage



\pagenumbering{arabic}
%De esta forma sale nombre de Tabla en vez de Cuadro
\renewcommand\tablename{Tabla}

\section{Introducción}
A lo largo de esta práctica, se ha realizado un compilador para un lenguaje tipo Pascal, del cual se nos proporciona la gramática que lo genera, así como ciertas pautas para la creación de este compilador. El objetivo es realizar un análisis completo hasta el punto de generación de código, el cual originalmente era orientado a la máquina virtual ROSSI. Sin embargo, debido a la falta de máquina virtual, la práctica finalmente se detiene en la creación del Árbol de Sintaxis Abstracta, sin que haya generación de código. \\

Esta memoria detallará las distintas partes que componen al compilador en su estado actual, de manera independiente, y explicando las partes del código que sean necesarias. Además, el proyecto con todo el código fuente, escrito en Python, se entregará de manera conjunta a esta memoria.

\section{Descripción formal del lenguaje}
\subsection{Categorías léxicas del lenguaje}
En nuestro compilador, se ha optado por representar cada categoría léxica con una clase. Por ello, al explicar cada categoría se hará referencia a la clase que la representa en el código. Todas estas clases se encuentran en el fichero \textit{componentes.py}
\begin{itemize}
	\item \textbf{Operador de asignación (\textit{OpAsigna}): } el operador de asignación se representa con dos puntos y un símbolo de igual (\textbf{:=})
	\item \textbf{Llave de Apertura (\textit{LlaveAp}): } La llave de apertura es el símbolo \textit{\{}
	\item \textbf{Llave de Cierre (\textit{Llaveci}): } La Llave de cierre es el símbolo \textit{\}}
	\item \textbf{Paréntesis de Apertura (\textit{ParentAp}): } El paréntesis de apertura es el símbolo \textit{(}
	\item \textbf{Paréntesis de Cierre (\textit{ParentCi}): } El paréntesis de cierre es el símbolo \textit{)}
	\item \textbf{Corchete de Apertura (\textit{CorAp}): } El corchete de apertura es el símbolo \textit{[}
	\item \textbf{Corchete de Cierre (\textit{CorCi}): } El corchete de cierre es el símbolo \textit{]}
	\item \textbf{Punto (\textit{Punto}): } El punto es el símbolo \textit{.}
	\item \textbf{Coma (\textit{Coma}): } La coma es el símbolo \textit{,}
	\item \textbf{Punto y Coma (\textit{PtoComa}): } El punto y coma es el símbolo \textit{;}
	\item \textbf{Dos Puntos (\textit{DosPtos}): } Los dos puntos es el símbolo \textit{:}
	\item \textbf{Fin de fichero (\textit{EOF}): } Esta categoría léxica, que no se representa con ningún caracter, nos permite saber cuando el fichero de entrada ha terminado de ser leído.
	\item \textbf{Operador de Suma (\textit{OpAdd}): } Este operador puede tomar dos valores aritméticos (\textit{+, -}).
	\item \textbf{Operador de Multiplicación (\textit{OpMult}): } Este operador puede tomar dos valores aritméticos (\textit{*, /})
	\item \textbf{Operador Relacional (\textit{OpRel}): } Este operador puede tomar los siguientes valores: \textit{=,<>,<,<=,>=,>}
	\item \textbf{Identificadores (\textit{Identif}): } Esta categoría léxica representa los identificadores que pueden aparecer en nuestro sistema. Éstos se generan a partir de la siguiente gramática: 
		\begin{align*}
			letra &\rightarrow [a-zA-Z] \\
			digito &\rightarrow [0-9] \\
			id &\rightarrow letra(letra|digito)^*
		\end{align*}
	\item \textbf{Número (\textit{Número}): } Esta categoría léxica representa los números que pueden aparecer en nuestro sistema, ya sean enteros o reales. Éstos se generan a partir de la siguiente gramática: 
		\begin{align*}
			digitos &\rightarrow digito \ digito^* \\
			fraccion\_opt &\rightarrow . \ digitos \ | \ \lambda \\
			num &\rightarrow  digitos \ fraccion\_opt \\
		\end{align*}
	\item \textbf{Palabra Reservada (\textit{PR}): } Esta categoría léxica representa el conjunto finito de palabras reservadas de nuestro sistema. Dichas palabras reservadas son: \textit{PROGRAMA,  VAR,  VECTOR,  ENTERO,  REAL,  BOOLEANO,  INICIO,  FIN,  SI,  ENTONCES, SINO, MIENTRAS, HACER, LEE, ESCRIBE, Y, O, NO, CIERTO} y \textit{FALSO}. Todas ellas deberán ir en mayúsculas.
\end{itemize}
\subsection{Máquina Discriminadora Determinista}
En esta sección se explicará cómo funciona la MDD en la implementación de nuestro compilador. Para ello, vamos a clasificar nuestras categorías léxicas en tres grandes grupos: Símbolos, Palabras y Números.
\subsubsection{Símbolos}
Dentro de este grupo, consideraremos todos los símbolos unitarios, los operadores y el fin de fichero. En este grupo, la mayoría de los elementos son únicos, y por lo tanto la MDD puede detectar directamente a que categoría pertenecen. En el caso de los símbolos compuestos de dos caracteres (operador de asignación u operador relacional), leemos el siguiente caracter. En caso de que sea un espacio, no existe ambiguedad (en el primer caso, sería la categoría \textbf{Dos puntos}, por ejemplo). Si no, el segundo caracter nos elimina también la ambiguedad del valor que puede tomar el operador.

\subsubsection{Palabras}
En este grupo consideramos los identificadores y las palabras reservadas, ya que se leen igual. La MDD lee el elemento mientras cumpla con la gramática establecida anteriormente, y una vez finaliza busca en la tabla de Palabras Reservadas si coincide con algún elemento. En caso contrario, sabemos que es un identificador. 

\subsubsection{Números}
Si el primer caracter que se lee es un dígito, la categoría léxica va a ser \textbf{Número}, ya que un identificador no puede comenzar por un dígito. La MDD lee en este caso, comprobando según la gramática especificada anteriormente si el número es Entero o Real.

\subsection{Comprobación de la gramática (A rellenar)}


\section{Detalles de implementación}
A la hora de implementar el sistema, se nos proporcionó una serie de ficheros con el esqueleto del código que tendríamos que completar. Dicho esqueleto contenía parte del analizador léxico, además de una implementación anterior del Árbol de Sintaxis Abstracta que se realizó el año anterior, y que nos ha servido de orientación para realizar nuestra propia implementación. Los ficheros proporcionados son: 
\begin{itemize}
	\item \textbf{componentes.py: } Es en este fichero donde se encuentran todas las clases que representan las distintas categorías léxicas. Sin embargo, las clases venían vacías, y se debía añadir el código necesario para almacenar la información necesaria (como el valor, en el caso de un Número) en cada clase.
	\item \textbf{flujo.py: } Contiene una clase que nos permite leer el flujo de entrada de un programa. Ya venía completo, así que no había que modificar este fichero
	\item \textbf{Prueba1.eje: } Este fichero contiene un pequeño programa de prueba para que se pueda testear el código que se va generando. 
	\item \textbf{analex.py: } El esqueleto del analizador léxico. Contenía el constructor de la clase, una función main para testear el programa que se le pasara por parámetro, y un ejemplo de como analizar la entrada.
\end{itemize}
A partir de estos ficheros, se ha generado un compilador capaz de crear un Árbol de Sintaxis Abstracta del código que se especifica en la descripción de la práctica.

\subsection{Analizador léxico}
Esta parte de nuestro compilador es la que implementa la MDD que se ha especificado anteriormente. Gracias al archivo \textbf{flujo.py}, contamos con una función \lstinline[language=Python]{siguiente()} que nos devuelve el siguiente caracter del fichero y una función \lstinline[language=Python]{devuelve()} que nos permite devolver el caracter leído al flujo, para volver a analizarlo (en caso de que hayamos entrado en un camino erróneo)

Hemos creado la función \lstinline[language=Python]{Analiza()}, que nos devuelve el componente léxico que viene a continuación. Para ello, lee el primer caracter para detectar la categoría léxica a la que pertenece con un \lstinline[language=Python]{if-else}, ya que Python no permite la instrucción \lstinline[language=Python]{switch}. Si el primer caracter es un espacio, o una llave de apertura (que nos marca el comienzo de un comentario) omite dicho caracter y sigue leyendo caracteres hasta que encuentra algo distinto del espacio (Listing 1) o la llave de cierre (Listing 2)

\begin{lstlisting}[language=Python, caption=Omisión de espacios]
	if ch==" ":
    while ch == " ":
    	ch = self.flujo.siguiente()
    self.flujo.devuelve(ch)
    return self.Analiza()
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Tratamiento de comentarios]
	elif ch == "{":
    while ch != "}":
    	ch = self.flujo.siguiente()
    return self.Analiza()
\end{lstlisting}

Cuando el caracter que lee la función es un caracter alfabético, sigue leyendo todos los caracteres alfanuméricos que le siguen hasta encontrar un espacio. Para ello, se hace uso de las funciones predefinidas de Python, que detectan los dígitos, caracteres, etc. Al completar la palabra, comprueba si se encuentra en la tabla de palabras reservadas, y devuelve la categoría léxica apropiada. (Listing 3)

\begin{lstlisting}[language=Python, caption=Detección de palabras]
	elif ch.isalpha():
    word = ""
    while ((ch).isalnum()):
    	word += ch
    	ch = self.flujo.siguiente()
    self.flujo.devuelve(ch)
    if word in self.PR:
    	return componentes.PR(word, self.nlinea)
    else:
    	return componentes.Identif(word, self.nlinea)
\end{lstlisting}

Cuando el caracter que se lee es un dígito, quiere decir que la categoría va a ser un Número. La función lee y guarda todos los dígitos hasta que se encuentra un espacio o un punto. En el primer caso, la función almacena que se trata de un Entero y devuelve la categoría correspondiente. En el segundo caso, la función comprueba que existe como mínimo un dígito después del punto, para almacenar que se trata de un Real; o devuelve un error. (Listing 4) 

\begin{minipage}{\linewidth}
	\begin{lstlisting}[language=Python, caption=Detección de números]
		elif ch.isdigit():
		num = ""
		num+=ch
		ch=self.flujo.siguiente()
		while(ch.isdigit()):
			num+=ch
			ch=self.flujo.siguiente()
		if (ch != '.'):
			self.flujo.devuelve(ch)
			return componentes.Numero(num, self.nlinea, 'ENTERO')
		else:
			newCh = self.flujo.siguiente()
			if not (newCh.isdigit()):
				self.flujo.devuelve(newCh)
				self.flujo.devuelve(ch)
				print "ERROR: NUMERO REAL MAL ESPECIFICADO" # tenemos un comentario no abierto
				return self.Analiza()
			num+=ch
			num+=newCh
			ch=self.flujo.siguiente()
			while((ch).isdigit()):
				num+=ch
				ch=self.flujo.siguiente()
			self.flujo.devuelve(ch)
			return componentes.Numero(num, self.nlinea, 'REAL')
	\end{lstlisting}
\end{minipage}


Por último, los caracteres no visibles como los saltos de línea o retornos de carro se tratan con su correspondiente codificación numérica, al no tener otra herramienta para tratarlos (Listing 5). Cualquier otro caracter no nulo hace que la función devuelva un error, mientras que al encontrar el primer caracter nulo se considera que se ha llegado al fin de fichero y se devuelve el componente correspondiente (Listing 6).

\begin{lstlisting}[language=Python, caption=Caracteres no visibles]
	elif (ch is not '' and ord(ch) == 13):
    	self.nlinea += 1
    	return self.Analiza()
	elif (ch is not '' and ord(ch) == 10):
    	return self.Analiza()
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=Errores y fin de fichero]
	elif len(ch) is not 0:
    	print "ERROR: CARACTER NO DEFINIDO EN LA ESPECIFICACION DEL LENGUAJE"
    	return self.Analiza()
	else:
    	return componentes.EOF()
\end{lstlisting}

\subsection{Analizador semántico}
Para la construcción del analizador semántico, no disponíamos de un esqueleto de código, pero si de unas instrucciones básicas en el material de clase de teoría. A partir de éstas, pudimos deducir la estructura del analizador semántico. En primer lugar, se han creado dos funciones que nos ayudarán con las comprobaciones. La primera es una función \lstinline[language=Python]{avanza()} que nos devuelve el siguiente componente en nuestro programa, extraido del analizador léxico explicado en la sección anterior. La segunda función, \lstinline[language=Python]{comprueba()}, nos realiza la comprobación de que un componente pertenece a una determinada categoría léxica, o devuelve un error. 

La aproximación que se ha tomado a la hora de programar el analizador semántico es la creación de una función por cada no terminal. En estas funciones, se van comprobando uno a uno los elementos que deberían aparecer, según la especificación sintáctica proporcionada en el material de la práctica. 

El primer paso es comprobar que el primer elemento leído pertenece a los primeros de la regla, que ya se han sacado y explicado anteriormente. Así, podemos detectar a qué regla ha entrado nuestro programa. Gracias a la función \lstinline[language=Python]{comprueba()} definida anteriormente, se van comprobando todos los terminales que deberían aparecer. En caso de que el elemento siguiente sea un no terminal, se llama a la función de dicho no terminal. Si la regla de producción es una regla vacía, no se hace nada en ese paso. Se puede observar como se ha hecho la implementación del no terminal $\nt{resto\_term}$ (Listings 7)
\begin{align*}
	\regla{resto\_term}{\textbf{opmult} \ \nt{factor} \nt{resto\_exsimple}}
	\regla{resto\_term}{\textbf{O} \ \nt{factor} \nt{resto\_exsimple}}
	\regla{resto\_term}{\lambda}
\end{align*}

\begin{minipage}{\linewidth}
	\begin{lstlisting}[language=Python, caption=analizaRestoTerm()]
		def analizaRestoTerm(self):
			if self.componente.cat == "OpMult":
				self.avanza()
				self.analizaFactor()
				self.analizaRestoTerm()
			elif self.componente.cat == "PR" and self.componente.valor == "Y":
				self.avanza()
				self.analizaFactor()
				self.analizaRestoTerm()
			elif (self.componente.cat == "PR" and self.componente.valor in ["ENTONCES", "HACER", "SINO", "O"]) or self.componente.cat == "ParentCi" or self.componente.cat == "CorCi" or self.componente.cat == "OpRel" or self.componente.cat == "PtoComa" or self.componente.cat == "OpAdd":
				pass
			else: 
				print "Error: SE ESPERABA Resto de Termino en linea " + str(self.lexico.nlinea)
				while not ((self.componente.cat == "PR" and self.componente.valor in ["O", "ENTONCES", "HACER", "SINO"]) or self.componente.cat == "OpRel" or self.componente.cat == "OpAdd" or self.componente.cat == "CorCi" or self.componente.cat == "ParentCi" or self.componente.cat == "PtoComa"):
					self.avanza()
				return
	\end{lstlisting}
\end{minipage}

Para el tratamiento de errores, se ha optado por un tratamiento en modo pánico. Esto quiere decir que si el componente que encontramos no es el componente esperado, avanzamos y tiramos todos los componentes que vienen a continuación hasta llegar a uno de los siguientes del no terminal que ha dado el problema. A partir de ahí, podemos continuar el análisis de una manera normal, habiendo informado del problema. Ésto se observa muy bien en el código anterior (Listings 7), ya que la condición \lstinline[language=Python]{else} muestra un bucle que va avanzando en el analizador léxico sin hacer nada con los componentes mientras el elemento no pertenezca a los siguientes de $\nt{resto\_term}$. Además, en el momento que encuentre un error, el compilador avisa de la línea de error y del tipo de error encontrado, mostrándolo por pantalla.


\end{document}
